
<h1 class="page-title">Class: Enhanced_Data_Object</h1>

<section>

    <!--==================================================
    =                   Overview
    ===================================================-->

    <header>
        <h2>
            <span class="ancestors"><a href="@link:/core/enhanced-data-object.js.html">core/enhanced-data-object.js</a>.</span>
            Enhanced_Data_Object
        </h2>

        <div class="container-overview">
            <div class="class-description">
                <p>
                    Represents an enhanced class storing a data object.
                </p>
            </div>
            <p>Base class: <span class="ancestors"><a href="@link:/core/data-object.js/Data_Object.html">core/data-object.js:Data_Object</a></span></p>
        </div>
    </header>

    <article>

        <!--==================================================
        =                   Members
        ===================================================-->

        <@section title="Members">

            <!-----------------------------------------
            |   register_data_type(data_type_name, def)
            ------------------------------------------>

            <@item title="static register_data_type(data_type_name, def)">
                <div class="description">
                    <p>
                        Adds (or sets) the data type definition (the <code>def</code> parameter) to the <code>jsgui.data_types_info</code> dictionary
                        for the <code>data_type_name</code> key.
                    </p>
                </div>

                <h5>Parameters:</h5>
                <@parms>
                    <@parm name="data_type_name" type="string" description="data type name" />
                    <@parm name="def" type="?" description="data type definition" />
                </@parms>

                <h5>Example</h5>
                <@codeblock>
                    var myDataTypeDef = { data: "myDataTypeData" };
                    Enhanced_Data_Object.register_data_type("myDataType", myDataTypeDef);
                    //
                    jsgui.data_types_info["myDataType"]  ===  myDataTypeDef
                </@codeblock>

                <h5>Remarks</h5>
                <p>
                    I found the only usage of this function in the <code>jsgui-html-core.js</code> module:
                </p>
                <@codeblock>
                    Enhanced_Data_Object.register_data_type('control_dom', jsgui.data_types_info['control_dom']);
                    Enhanced_Data_Object.register_data_type('dom_attributes', jsgui.data_types_info['dom_attributes']);
                </@codeblock>
                <p>
                    <mark>It looks very strange</mark> because it does the following in fact:
                </p>
                <@codeblock>
                    jsgui.data_types_info['control_dom'] = jsgui.data_types_info['control_dom'];
                    jsgui.data_types_info['dom_attributes'] = jsgui.data_types_info['dom_attributes'];
                </@codeblock>


            </@item>

            <!-----------------------------------------
            |          map_data_type_data_object_constructors
            ------------------------------------------>

            <@item title="static map_data_type_data_object_constructors">
                <div class="description">
                    <p>
                        It is exactly the same name/value array as <a href="@link:/core/data-object.js/Data_Object.html#map_data_type_data_object_constructors">Data_Object.map_data_type_data_object_constructors</a>.
                    </p>
                    <p>
                        <code>Data_Object.map_data_type_data_object_constructors === jsgui.map_data_type_data_object_constructors</code>
                        <code>Enhanced_Data_Object.map_data_type_data_object_constructors === jsgui.map_data_type_data_object_constructors</code>
                    </p>
                    <p>
                        <strong>By the way</strong>, Enhanced_Data_Object uses a slightly different
                        <a href="@link:/core/data-object.js/Data_Object.html#ensure_data_type_data_object_constructor__data_type_name">ensure_data_type_data_object_constructor(data_type_name)</a>
                        function version: it creates an Enhanced_Data_Object descendant instead of Data_Object one.
                        The <code>enhanced-data-object.js</code> module registers the different function version as <code> jsgui.ensure_data_type_data_object_constructor</code> global variable.
                    </p>
                </div>

                <h5>Example</h5>
                <@codeblock>
                    // The following code is contained in the data_object.js module:
                    jsgui.map_data_type_data_object_constructors['boolean'] = Data_Value;
                </@codeblock>
            </@item>

            <!-----------------------------------------
            |          new Enhanced_Data_Object(spec)
            ------------------------------------------>

            <@item title="new Enhanced_Data_Object(spec-opt)">
                <div class="description">
                    <p>
                        Creates the Enhanced_Data_Object instance.
                    </p>
                    <p>
                        In addition to the <a href="@link:/core/data-object.js/Data_Object.html#newdata_object__spec">Data_Object initialization</a>, 
                        it adds a <code>flags</code> field:
                    </p>
                    <@codeblock>
                        var Enhanced_Data_Object = Data_Object.extend({
                            'fields': [['flags', Collection(String)]],
                            ...
                        });
                    </@codeblock>
                </div>

                <h5>Example</h5>
                <@codeblock>
                    var edo = new Enhanced_Data_Object();
                </@codeblock>
            
                <h5 class="content-part-header collapsed"><mark>flags issue</mark></h5>
                <div>
                    <p>
                       The <code>flags</code> collection field added in the constructor seems not created by the <code>new Collection(String)</code> call. 
                       It has no data_type constraint, and no indexes.
                       <mark>As result, the collection <code>has()</code> and <code>remove()</code> methods does not work properly:</mark>
                    </p>
                    <@codeblock>
	                    var edo = new Enhanced_Data_Object();
	                    var flags = edo.get('flags');
	                    stringify(flags)  ==>  "Collection()"
                        //
	                    flags.add('selectable');
	                    flags.add('resizable');
	                    stringify(flags)  ==>  'Collection("selectable", "resizable")'
	                    //
	                    // the Enhanced_Data_Object() constructor does not set data_type constraint
	                    // for the "flags" collection. 
                        // So, flags.has() result is always undefined:
	                    flags._data_type_constraint  ==>  undefined
	                    flags.has('selectable')  ==>  undefined
	                    flags.has('resizable')  ==>  undefined
	                    //
                        //
	                    // the Enhanced_Data_Object() constructor does not set indexes
	                    // for the "flags" collection. 
	                    // So, flags.remove() throws an error:
	                    assert.throws(function(){ flags.remove('selectable');});
	                    // must be: assert.equal(stringify(flags), 'Collection("resizable")');
                        //
	                    flags.has('selectable')  ==>  undefined
	                    flags.has('resizable')  ==>  undefined
                        //
	                    edo.add_flag('hidden');
	                    stringify(flags)  ==>  'Collection("selectable", "resizable", "hidden")'
                    </@codeblock>
                </div>
            
            </@item>

            <!-----------------------------------------
            |   _get_input_processors()
            ------------------------------------------>

            <@item title="_get_input_processors()">
                <div class="description">
                    <p>
                        Returns <code>jsgui.input_processors</code> variable (exactly as <a href="@link:/core/data-object.js/Data_Object.html#_get_input_processors">Data_Object._get_input_processors()</a> method).
                    </p>
                </div>
            </@item>

            <!-----------------------------------------
            |   add_flag(flag_name)
            ------------------------------------------>

            <@item title="add_flag(flag_name)">
                <div class="description">
                    <p>
                        Adds a flag <code>flag_name</code> to the object flags collection.
                        <mark>The implementation code tries to skip if the flag is added already, but the attempt is unsuccessful because of an error.</mark>
                    </p>
                </div>

                <h5>Parameters:</h5>
                <@parms>
                    <@parm name="flag_name" type="string" description="Flag name" />
                </@parms>

                <h5>Example</h5>
                <@codeblock>
                    var edo = new Enhanced_Data_Object();
                    //
                    edo.add_flag("test");
                    //
                    jsgui.stringify(edo.get('flags'))  ==>  'Collection("test")'
                    //
                    edo.add_flag("test");
                    //
                    jsgui.stringify(edo.get('flags'))  ==>  'Collection("test", "test")'
                </@codeblock>

            </@item>

            <!-----------------------------------------
            |   remove_flag(flag_name)
            ------------------------------------------>

            <@item title="remove_flag(flag_name)">
                <div class="description">
                    <p>
                        Probably should remove the flag <code>flag_name</code> from the object flags collection.
                        <mark>But it does not works.</mark>
                    </p>
                </div>

                <h5>Parameters:</h5>
                <@parms>
                    <@parm name="flag_name" type="string" description="Flag name" />
                </@parms>

                <h5>Example</h5>
                <@codeblock>
                    var edo = new Enhanced_Data_Object();
                    //
                    edo.add_flag("test");
                    //
                    jsgui.stringify(edo.get('flags'))  ==>  'Collection("test")'
                    //
                    edo.remove_flag("test");
                    //
                    jsgui.stringify(edo.get('flags'))  ==>  'Collection("test")'
                </@codeblock>

            </@item>

            <!-----------------------------------------
            |   has_flag(flag_name)
            ------------------------------------------>

            <@item title="has_flag(flag_name)">
                <div class="description">
                    <p>
                        Probably should check if the flag <code>flag_name</code> is added to the object flags collection, and return <code>true</code> or <code>false</code>.
                        <mark>But it always return <code>undefined</code>.</mark>
                    </p>
                </div>

                <h5>Parameters:</h5>
                <@parms>
                    <@parm name="flag_name" type="string" description="Flag name" />
                </@parms>

                <h5>Example</h5>
                <@codeblock>
                    var edo = new Enhanced_Data_Object();
                    //
                    edo.has_flag("test")  ==>  undefined
                    //
                    edo.add_flag("test");
                    //
                    edo.has_flag("test")  ==>  undefined
                </@codeblock>

            </@item>


            <!-----------------------------------------
            -------------------------------------------
            |   get()
            -------------------------------------------
            ------------------------------------------>

            <@overloads title="get()">

                <div class="description">
                    <p>
                        By the way, it tries to apply <code>Data_Object.get()</code> method when <code>typeof this.__data_type_name !== 'undefined'</code>
                        (instead of all other processing).
                        But the <code>__data_type_name</code> prop seems not set anywhere in the JSGUI library code.
                    </p>
                </div>

                <!-----------------------------------------
                |   get()
                ------------------------------------------>

                <@item title="get()">
                    <div class="description">
                        <p>
                            Just returns an internal storage object containing the field values (<em>exactly as Data_Object</em>).
                        </p>
                    </div>

                    <h5>Example</h5>
                    <@codeblock>
                        var data_object = new Enhanced_Data_Object();
                        //
                        data_object.get()  ==>  {}
                        //
                        data_object.set("Field1", [100]);
                        data_object.set("Field2", ["200"]);
                        //
                        data_object.get()  ==>  { Field1: [100], Field2: ["200"] }
                    </@codeblock>
                </@item>

                <!-----------------------------------------
                |   get(field_name)
                ------------------------------------------>

                <@item title="get(field_name)">
                    <div class="description">
                        <p>
                            Returns a field value for the <code>field_name</code>.
                        </p>
                        
                        <h5>Parameters:</h5>
                        <@parms>
                            <@parm name="field_name" type="string" description="Field name" />
                        </@parms>
                                                       
                        <p>
                            The main get(field_name) algorithm is the following <em>(same as for Data_Object)</em>:
                            <@codeblock>
                                function get(field_name) {
                                    if (field_name.indexOf('.') > -1) return processQualifiedName();
                                    //
                                    if (!fc.get(field_name)) {
                                        // field_name field was not defined:
                                        var res = ll_get(_, field_name);
                                        if (res) return res;
                                        return this[field_name];
                                    } else {
                                        // field_name field was defined:
                                        if (!_[field_name]) {
                                            _[field_name] = createValueBasedOnFieldDefinition(); // Data_Object or Data_Value usually
                                            return _[field_name];
                                        } else {
                                            return _[field_name];
                                        }
                                    }
                                }
                            </@codeblock>
                        </p>

                        <h5 class="content-part-header collapsed">processQualifiedName()</h5>

                        <p >
                            If <code>field_name</code> is a qualified name (i.e. contains several names delimited by dot characters, like "a.b.c"), then
                            it applies the get() method to all the names from the chain, and returns the result:
                        </p>

                        <@codeblock>
                            data_object.get("a.b.c") === data_object.get("a").get("b").get("c")
                        </@codeblock>

                        <p>
                           There is a <strong><em>small difference</em></strong> between <code>Data_Object</code> and <code>Enhanced_Data_Object</code> 
                           when an intermediate object not exists: <code>Data_Object</code> returns <code>undefined</code>, 
                           but <code>Enhanced_Data_Object</code> throws an exception.
                        </p>
                        
                        <h5 class="content-part-header collapsed">field_name field was not defined</h5>
                        
                        <p>
                            <strong><em>The behaviour is exactly the same as for <code>Data_Object</code>.</em></strong>
                        </p>
                        <p>
                            If the <code>field_name</code> field was not defined for this Data_Object, then it tries to get an appropriate value
                            from an internal data object (the <code>_</code> property). By the way, it uses the
                            <a href="@link:/core/jsgui-lang-essentials.js.html#ll_get">ll_get()</a> method call internally to get the value, but <a href="@link:/core/jsgui-lang-essentials.js.html#ll_get">ll_get()</a> power seems
                            not used here. Moreover, the pair <a href="@link:/core/jsgui-lang-essentials.js.html#ll_set">ll_set()</a> method is not used in the Data_Object.set() method. So, <code>ll_get(_, field_name)</code> call
                            works like <code>_[field_name]</code> here.
                        </p>


                        <@codeblock>
                            var data_object = new Enhanced_Data_Object();
                            //
                            // set_field() not called, Field1 and Field2 fields are not defined
                            //
                            data_object.set("Field1", "abc"); // set() creates a Data_Value for string types:
                            data_object.get("Field1")  ==>  new Data_Value({ value: "abc" })
                            //
                            data_object.set("Field2", ["abc"]); // set() assigns array types directly, without Data_Value creation:
                            data_object.get("Field2")  ==>  ["abc"]
                        </@codeblock>

                        <p>
                            If the field value was not found (more precisely: if the <a href="@link:/core/jsgui-lang-essentials.js.html#ll_get">ll_get()</a> call returned
                            something evaluated to <code>false</code>), then it tries to get a <code>field_name</code> property of the Data_Object itself.
                        </p>

                        <@codeblock>
                            var data_object = new Enhanced_Data_Object();
                            //
                            // ll_get() returns a Data_Value object:
                            //
                            data_object.set("Field1", false);
                            data_object.get("Field1")  ==>  new Data_Value({ value: false })
                            //
                            // ll_get() returns null, so it tries to get data_object.Field2 property:
                            //
                            data_object.set("Field2", null);
                            data_object.get("Field2")  ==>  undefined
                            //
                            //  "_" field was not defined, ll_get() returns undefined, so it tries to get data_object._ property:
                            //
                            data_object.get("_")  ==>  { Field1: new Data_Value({ value: false }), Field2: null }
                        </@codeblock>

                        <h5 class="content-part-header collapsed">field_name field was defined</h5>

                        <div>
                            
                        <p>
                            If the <code>field_name</code> field was defined, then <code>get()</code> just returns the field value. But if the field value was not set previously
                            (more precisely: if <code>_[field_name]</code> evaluates to <code>false</code>), then it tries to create the value first.
                        </p>

                        <p>
                            The field definition can be done using many different object formats, and the creating value depends of the format first of all. The code
                            processing the formats and creating the value is placed directly into the get() method.
                        </p>
                        <p>
                            The get() method selects a code branch to create the value depending of the internal format signature. Meanwhile it will be described here
                            using the signatures too.
                        </p>


                        <p class="content-part-header collapsed"><strong>[s,s,f]</strong></p>
                        
                        <div>
                                
                        <p>
                            The [s,s,f] format parts are [field_name, fieldStrType, fieldDef]<br /><br />
                            <strong><em><code>Data_Object</code> processes this format, but <code>Enhanced_Data_Object</code> does not. The field values still be not set.</em></strong>
                        </p>

                        <@codeblock>
                            //
                            // differs from Data_Object: always undefined
                            //
                            var data_object = new Enhanced_Data_Object();
                            //
                            data_object.set_field("Field_String", String); assert_field_sig(data_object, "Field_String", "[s,s,f]");
                            assert.deepEqual(data_object.get("Field_String"), undefined);
                            //
                            data_object.set_field("Field_Number", Number); assert_field_sig(data_object, "Field_Number", "[s,s,f]");
                            assert.deepEqual(data_object.get("Field_Number"), undefined);
                            //
                            var MyBook = function () { this.book = "Secret City"; };
                            //
                            data_object.set_field("Field_MyBook", MyBook); assert_field_sig(data_object, "Field_MyBook", "[s,s,f]");
                            assert.deepEqual(data_object.get("Field_MyBook"), undefined); // new MyBook());
                            //
                            //
                            assert.deepEqual(data_object.get(), {});
                        </@codeblock>

                        </div>
                            
                       <p class="content-part-header collapsed"><strong>[s,[s,u]]</strong></p>

                        <p>
                            Throws an error, but I see no way to define a field using this format.
                        </p>
                    
                        <p class="content-part-header collapsed"><strong>[s,s,o]</strong></p>
                            
                        <div>
                            
                        <p>
                            The [s,s,o] format parts are [field_name, field_type_name, field_info]<br /><br />
                            Depending of the field_type_name part, the resulting values will be following:
                            <ul>
                                <li>
                                    <strong><code>'collection'</code></strong>: <code>new Collection({'context': this._context});</code>
                                </li>
                                <li>
                                    <strong><code>'data_object'</code></strong>: <code>new Data_Object({'context': this._context}); result.parent(this);</code>
                                </li>
                                <li>
                                    <strong><code>'ordered_string_list'</code></strong>: error (tries to create <code>new Ordered_String_List();</code>, but Ordered_String_List not defined)
                                </li>
                                <li>
                                    <strong><code>'string'</code></strong>: <code>new Data_Value({'context': this._context});</code>
                                </li>
                                <li>
                                    <strong>other</strong>: see below
                                </li>
                            </ul>                       
                        </p>
                               
                        <p>
                            In other cases calculates a constructor using the <code>ensure_data_type_data_object_constructor()</code> method, then creates the value. Usually:<br />
                            <code>result = new constructor({'context': this._context}); result.parent(this);</code>
                        </p>

                        <p>
                            <mark><strong><em>Data_Object differences:</em></strong></mark>
                            <ul>
                                <li>
                                    <strong><code>'collection'</code></strong>: Enhanced_Data_Object works, Data_Object fails.
                                </li>
                                <li>
                                    <strong><code>'ordered_string_list'</code></strong>: Data_Object works, Enhanced_Data_Object fails.
                                </li>
                                <li>
                                    <strong>other</strong>: see below
                                </li>
                            </ul>                       
                        </p>
                            
                        <p>
                            For "other" case Data_Object processes <code>field_info.data_type</code>, and creates <code>Data_Value</code> 
                            for <code>["text",length]</code> and <code>["int"]</code> data types. Enhanced_Data_Object does not process <code>field_info.data_type</code>.
                        </p>
                        <p>
                           If the value was not created at the previous step, then they both use <code>ensure_data_type_data_object_constructor()</code> function to get an object constructor, 
                           and create the value object. In contrast to Data_Object, Enhanced_Data_Object can call the constructor 
                           without the <code>context</code> spec passing (if its own context not set). Also, Enhanced_Data_Object processes 
                           <code>field_info.default</code> default value (calls <code>field_val.set(default_value)</code> if present).
                        </p>
                                
                        <@codeblock>
                            var data_object = new Enhanced_Data_Object();
                            //
                            // "collection" differs from Data_Object: Enhanced_Data_Object creates the value successfully
                            //
                            data_object.set_field("Field_collection", "collection"); assert_field_sig(data_object, "Field_collection", "[s,s,o]");
                            //Data_Object: assert.throws(function () { data_object.get("Field_collection") });  // it's unable to create this field (line 4172 jsgui.Collection undefined) !!!
                            var value_Collection = new jsgui.Collection({ 'context': data_object._context });
                            assert.deepEqual(jsgui.stringify(data_object.get("Field_collection")), jsgui.stringify(value_Collection));
                            //
                            data_object.set_field("Field_data_object", "data_object"); assert_field_sig(data_object, "Field_data_object", "[s,s,o]");
                            var value_data_object = new Enhanced_Data_Object();
                            value_data_object._parent = data_object;                                    // !!!
                            test_utils.assertDeepEqual(data_object.get("Field_data_object"), value_data_object);
                            //
                            // "ordered_string_list" differs from Data_Object: Enhanced_Data_Object code forgot to add the Ordered_String_List reference:
                            //
                            data_object.set_field("Field_ordered_string_list", "ordered_string_list"); assert_field_sig(data_object, "Field_ordered_string_list", "[s,s,o]");
                            //var value_ordered_string_list = new Data_Structures.Ordered_String_List();
                            //var v1_ordered_string_list = test_utils.functionsToStrings(data_object.get("Field_ordered_string_list"));
                            //var v2_ordered_string_list = test_utils.functionsToStrings(value_ordered_string_list);
                            //assert.deepEqual(v1_ordered_string_list, v2_ordered_string_list);
                            assert.throws(function () { data_object.get("Field_ordered_string_list"); });
                            //
                            data_object.set_field("Field_string", "string"); assert_field_sig(data_object, "Field_string", "[s,s,o]");
                            var value_string = new Data_Value();
                            value_string._parent = data_object; // !!!
                            assert.deepEqual(data_object.get("Field_string"), value_string);
                            //
                            // all other differs from Data_Object. Data_Object tries to process data_type_name avoiding ensure_data_type_data_object_constructor()
                            // in the next tests; but Enhanced_Data_Object uses ensure_data_type_data_object_constructor() code branch.
                            //
                            data_object.set_field("Field_text", "text", { data_type: ["text", 10] }); assert_field_sig(data_object, "Field_text", "[s,s,o]");
                            var value_text = new (jsgui.ensure_data_type_data_object_constructor("text"))();
                            value_text.parent(data_object);
                            test_utils.assertDeepEqual(data_object.get("Field_text"), value_text);
                            //
                            data_object.set_field("Field_text2", "text"); assert_field_sig(data_object, "Field_text2", "[s,s,o]");
                            test_utils.assertDeepEqual(data_object.get("Field_text2"), value_text);
                            //
                            data_object.set_field("Field_int", "int"); assert_field_sig(data_object, "Field_int", "[s,s,o]");
                            var value_int = new (jsgui.ensure_data_type_data_object_constructor("int"))();
                            value_int.parent(data_object);
                            test_utils.assertDeepEqual(data_object.get("Field_int"), value_int);
                            //
                            data_object.set_field("Field_wrong", "wrong"); assert_field_sig(data_object, "Field_wrong", "[s,s,o]");
                            var value_wrong = new (jsgui.ensure_data_type_data_object_constructor("wrong"))();
                            value_wrong.parent(data_object);
                            test_utils.assertDeepEqual(data_object.get("Field_wrong"), value_wrong);
                        </@codeblock>

                        </div>
                            
                        <p class="content-part-header collapsed"><strong>[s,s]</strong></p>

                        <div>
                            
                        <p>                           
                            The [s,s] format parts are [field_name, field_type_name]<br /><br />
                        
                            Depending of the field_type_name part, the resulting values will be following:
                            <ul>
                                <li>
                                    <strong><code>'collection'</code></strong>: new Collection(...)
                                </li>
                                <li>
                                    <strong><code>'control'</code></strong>: return undefined
                                </li>
                                <li>
                                    <strong><code>'string'</code></strong>: new Data_Value(...)
                                </li>
                                <li>
                                    <strong>other</strong>: return undefined
                                </li>
                            </ul>                       
                        </p>

                        <p>
                            <mark><strong><em>Data_Object differences:</em></strong></mark>
                        </p>
                        <p>
                            Everything is different. No common results found here.
                        </p>
                            
                        <@codeblock>
                            var data_object = new Enhanced_Data_Object();
                            //
                            data_object.set_field(0, ["Field_collection", "collection"]); assert_field_sig(data_object, "Field_collection", "[s,s]");
                            var value_collection = new jsgui.Collection({ 'context': data_object._context });
                            value_collection.parent(data_object);
                            test_utils.assertDeepEqual(data_object.get("Field_collection"), value_collection);
                            //
                            data_object.set_field(0, ["Field_control", "control"]); assert_field_sig(data_object, "Field_control", "[s,s]");
                            test_utils.assertDeepEqual(data_object.get("Field_control"), undefined);
                            //
                            data_object.set_field(0, ["Field_string", "string"]); assert_field_sig(data_object, "Field_string", "[s,s]");
                            var value_string = new Data_Value();
                            value_string.parent(data_object);
                            test_utils.assertDeepEqual(data_object.get("Field_string"), value_string);
                            //
                            // other cases try to use jsgui.map_data_type_data_object_constructors[], 
                            // but the code refers jsgui as this._module_jsgui - it is undefined
                            // so the results below are always undefined
                            //
                            data_object.set_field(0, ["Field_other", "other"]); assert_field_sig(data_object, "Field_other", "[s,s]");
                            test_utils.assertDeepEqual(data_object.get("Field_other"), undefined); // intended to use map_data_type_data_object_constructors["other"]
                            //
                            data_object.set_field(0, ["Field_other2", "other2"]); assert_field_sig(data_object, "Field_other2", "[s,s]");
                            test_utils.assertDeepEqual(data_object._module_jsgui, undefined);
                            jsgui.map_data_type_data_object_constructors["other2"] = Data_Value;
                            //var value_other2 = new Data_Value();
                            //value_other2.parent(data_object);
                            test_utils.assertDeepEqual(data_object.get("Field_other2"), undefined); // value_other2);
                            //
                            data_object.set_field(0, ["Field_data_object", "data_object"]); assert_field_sig(data_object, "Field_data_object", "[s,s]");
                            test_utils.assertDeepEqual(data_object.get("Field_data_object"), undefined);
                        </@codeblock>

                        </div>
                            
                        <p class="content-part-header collapsed"><strong>[s,[s,s]]</strong></p>
                            
                        <div>
                        <p>                           
                            The [s,[s,s]] format parts are [field_name, [data_type_name, collection_type_name]]
                        </p>
                        <p>
                            If the <code>data_type_name === 'collection'</code>, then creates new Collection object. The <code>collection_type_name</code> is not used.
                        </p>
                        <p>
                            There is no way to set <code>data_type_name</code> to value other than <code>'collection'</code> (because of the 
                            <a href="@link:/core/data-object-fields-collection.js/Fields_Collection.html#set__array">Fields_Collection.set()</a> method behaviour).
                        </p>
                        <h6>Data_Object differences:</h6>
                        <p>
                            Data_Object does not process this format (returns <code>undefined</code>).
                        </p>

                        <@codeblock>
                            var data_object = new Enhanced_Data_Object();
                            //
                            data_object.set_field("Field_collection", ["collection", "int"]); assert_field_sig(data_object, "Field_collection", "[s,[s,s]]");
                            var value_collection = new jsgui.Collection({ 'context': data_object._context });
                            value_collection.parent(data_object);
                            test_utils.assertDeepEqual(data_object.get("Field_collection"), value_collection);
                            //
                            data_object.set_field("Field_dictionary", ["dictionary", "int"]); assert_field_sig(data_object, "Field_dictionary", "u"); // !!!
                        </@codeblock>
                        </div>

                            
                        <p class="content-part-header collapsed"><strong>[s,[s,o]]</strong></p>
                            
                        <div>
                        <p>                           
                            The [s,[s,o]] format parts are [field_name, [data_type_name, objDef]]                           
                        </p>
                        <p>
                            If the <code>data_type_name === 'collection'</code>, then creates new Collection object, and calls <code>fields()</code> method 
                            passing <code>objDef</code> fields definition.
                        </p>
                        <p>
                            If <code>data_type_name !== 'collection'</code>, then returns <code>undefined</code>.
                        </p>
                        <h6>Data_Object differences:</h6>
                        <p>
                            Data_Object does not process this format (throws an exception or returns <code>undefined</code>).
                        </p>

                        <@codeblock>
                            var data_object = new Enhanced_Data_Object();
                            //
                            data_object.set_field("Field_collection", [{ Field1: "int", Field2: "text" }]); assert_field_sig(data_object, "Field_collection", "[s,[s,o]]");
                            assert.deepEqual(data_object.fc.get("Field_collection"), ["Field_collection", ["collection", { Field1: "int", Field2: "text" }]]);
                            //
                            var value_collection = new jsgui.Collection({ 'context': data_object._context });
                            value_collection.fields({ Field1: "int", Field2: "text" });
                            value_collection.parent(data_object);
                            test_utils.assertDeepEqual(data_object.get("Field_collection"), value_collection);
                            //
                            data_object.set_field("Field_data_object", {}); assert_field_sig(data_object, "Field_data_object", "[s,[s,o]]");
                            assert.deepEqual(data_object.fc.get("Field_data_object"), ["Field_data_object", ["data_object", {}]]);
                            assert.deepEqual(data_object.get("Field_data_object"), undefined);
                        </@codeblock>
                        </div>
                            
                        </div>
                            
                    </div>

                </@item>

            </@overloads>

            
            <!-----------------------------------------
            |   extend(prop, namespcExtension, propsToMerge)
            ------------------------------------------>

            <@item title="static extend(prop, namespcExtension, propsToMerge)">
                <div class="description">
                    <p>
                        Just calls a <a href="@link:/core/data-object.js/Data_Object.html#extend__prop_post_init">Data_Object.extend()</a> method passing the parameters.
                    </p>
                    <p>
                        If the <code>prop</code> parameter contains a <code>.flags</code> field, then sets <code>._flags</code> field for the resulting class. <mark>This field is not used anywhere.</mark>
                    </p>
                </div>

                <h5>Parameters:</h5>
                <@parms>
                    <@parm name="prop" type="string" description="see Data_Object.extend()" />
                    <@parm name="namespcExtension" type="string" description="not used" />
                    <@parm name="propsToMerge" type="string" description="not used" />
                </@parms>

                <h5>Example</h5>
                <@codeblock>
                    var EDO2 = new Enhanced_Data_Object();
                    var edo2 = new EDO2();
                </@codeblock>

            </@item>
            
            <!-----------------------------------------
            |          Side effects
            ------------------------------------------>

            <@item title="Side effects" class="remark">

                <@codeblock>
                    jsgui.ensure_data_type_data_object_constructor = ensure_data_type_data_object_constructor;
                    // (differs from Data_Object.ensure_data_type_data_object_constructor: uses Enhanced_Data_Object instead of Data_Object)
                    //
                    Data_Object.set_Enhanced_Data_Object(Enhanced_Data_Object);
                    //
                    // Enhanced_Data_Object.register_data_type() changes jsgui.data_types_info[]
                    //
                    // ensure_data_type_data_object_constructor() changes jsgui.map_data_type_data_object_constructors[]
                </@codeblock>

                <p>
                    <code>require('core/enhanced-data-object')</code> call produces <code>String.abstract = true;</code> side effect because it calls 
                    <code>Collection(String)</code> in the module code. 
                    See <a href="@link:/core/data-object.js/Data_Object.html#extend_side_effect">Data_Object.extend() side effect</a>
                    for an additional info.
                </p>
                
                <@codeblock>
	                // everything is ok:
	                String.abstract  ==>  undefined
	                stringify(new Data_Object(String))  ==>  "Data_Object({})"
	                stringify(new Collection(String))  ==>  "Collection()"
	                //
	                // require('enhanced-data-object') calls Collection(String) inside, and sets String.abstract = true:
	                var Enhanced_Data_Object = require('../../../core/enhanced-data-object');
	                //
	                // now it's broken:
	                String.abstract  ==>  true
	                stringify(new Data_Object(String))  ==>  "Data_Object(undefined)"
	                stringify(new Collection(String))  ==>  "~Collection(String)"
	                //
	                // fix back:
	                delete String.abstract;
	                //
	                // now it's fixed:
	                String.abstract  ==>  undefined
	                stringify(new Data_Object(String))  ==>  "Data_Object({})"
	                stringify(new Collection(String))  ==>  "Collection()"
                </@codeblock>
            </@item>


        </@section>

    </article>

</section>

